{"canmore.update_textdoc":{"updates":[{"pattern":".*","multiple":false,"replacement":"# üöÄ Spring Boot CI/CD on Kubernetes (EKS/Minikube) with Helm & ArgoCD\n\nThis project demonstrates end-to-end CI/CD for a Spring Boot application using Helm, ArgoCD, Kubernetes (EKS/Minikube), AWS, EC2, and optionally NGINX Ingress. It also includes Jenkins pipeline fixes for AWS CLI, Helm, and credentials.\n\n---\n\n## üìë Table of Contents\n- Prerequisites\n- AWS EKS Cluster Setup\n- Helm Chart Structure & Fixes\n- ArgoCD Setup & Application Deployment\n- LoadBalancer Service & Browser Access\n- NGINX Ingress Setup (Optional)\n- Jenkins Pipeline & AWS/EKS Fixes\n- Troubleshooting\n- Summary Flow\n\n---\n\n## üîë Prerequisites\n\n| Item | Details |\n|----------------|---------|\n| EC2 Instance | Ubuntu 24.04, 2 vCPU, 4GB RAM, Docker installed, Internet access |\n| AWS Account | IAM user with Admin privileges or sufficient EKS permissions |\n| AWS CLI | v2 installed and configured (aws configure) |\n| Jenkins | Plugins: Git, Pipeline, Docker Pipeline, Kubernetes CLI, SonarQube Scanner, Credentials Binding, GitHub Branch Source |\n| Maven & JDK | Maven 3.8.7, JDK 17 |\n| DockerHub | Repository: venkatesh384/java-cicd-app |\n| SonarQube | Server URL & token configured in Jenkins |\n\n---\n\n## üöÄ AWS EKS Cluster Setup\n\n### 1Ô∏è‚É£ IAM User & AWS CLI\nbash\naws configure\naws sts get-caller-identity\n\n\nInstall AWS CLI:\nbash\ncurl \"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\" -o \"awscliv2.zip\"\nunzip awscliv2.zip\nsudo ./aws/install\naws --version\n\n\n### 2Ô∏è‚É£ Create EKS Cluster\nbash\neksctl create cluster \\\n --name java-eks \\\n --region ap-south-1 \\\n --nodegroup-name java-eks-nodes \\\n --node-type t3.medium \\\n --nodes 2 \\\n --managed\n\n\nVerify:\nbash\nkubectl get nodes\n\n\n### 3Ô∏è‚É£ Nginx Test Deployment\nbash\nkubectl create deployment nginx --image=nginx --replicas=2\nkubectl expose deployment nginx --port=80 --type=LoadBalancer\nkubectl get svc nginx\ncurl http://<nginx-ELB-DNS>\n\n\n---\n\n## ‚öôÔ∏è Helm Chart Structure & Fixes\n\n\nspringboot-helm-chart/\n‚îú‚îÄ‚îÄ Chart.yaml\n‚îú‚îÄ‚îÄ values.yaml\n‚îî‚îÄ‚îÄ templates/\n ‚îú‚îÄ‚îÄ deployment.yaml\n ‚îú‚îÄ‚îÄ service.yaml\n ‚îú‚îÄ‚îÄ ingress.yaml\n ‚îú‚îÄ‚îÄ namespace.yaml\n ‚îú‚îÄ‚îÄ serviceaccount.yaml\n ‚îú‚îÄ‚îÄ rolebinding.yaml\n ‚îú‚îÄ‚îÄ hpa.yaml\n ‚îî‚îÄ‚îÄ configmap.yaml\n\n\nChart.yaml\nyaml\napiVersion: v2\nname: springboot-app\ndescription: Spring Boot app deployment on Kubernetes/EKS\nversion: 0.1.0\nappVersion: \"1.0\"\n\n\nvalues.yaml\nyaml\nreplicaCount: 2\nimage:\n repository: venkatesh384/java-cicd-app\n tag: 41\n pullPolicy: IfNotPresent\nserviceAccount:\n name: java-cicd-deployer\nservice:\n type: LoadBalancer\n port: 80\n targetPort: 8080\ningress:\n enabled: true\n host: java-app-new.local\nresources:\n requests:\n cpu: \"100m\"\n memory: \"128Mi\"\n limits:\n cpu: \"500m\"\n memory: \"512Mi\"\nnamespace:\n name: java-app\nhpa:\n enabled: true\n minReplicas: 2\n maxReplicas: 5\n targetCPUUtilizationPercentage: 60\nconfigmap:\n enabled: true\n APP_MESSAGE: \"Hello from End-to-End CI/CD Pipeline (Helm)\"\n\n\nFixes (_helpers.tpl):\nyaml\n{{- define \"springboot-app.name\" -}}\n{{ .Chart.Name }}\n{{- end -}}\n\n{{- define \"springboot-app.fullname\" -}}\n{{ .Release.Name }}-{{ .Chart.Name }}\n{{- end -}}\n\n\nDeploy:\nbash\nhelm upgrade --install java-app ./springboot-helm-chart --namespace java-app --create-namespace\n\n\n---\n\n## üéØ ArgoCD Setup & Application Deployment\n\nExpose ArgoCD:\nbash\nkubectl edit svc argocd-server -n argocd # change type=LoadBalancer\nkubectl get svc -n argocd\n\n\nLogin:\nbash\nkubectl get secret argocd-initial-admin-secret -n argocd -o jsonpath=\"{.data.password}\" | base64 -d\n\n\nargocd-helm-app.yaml\nyaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n name: java-app\n namespace: argocd\nspec:\n project: default\n source:\n repoURL: 'https://github.com/venkateswarluyendoti/EndtoEnd-CI-CD-Pipeline-for-Java-Application.git'\n targetRevision: main\n path: springboot-helm-chart\n helm:\n releaseName: java-app\n destination:\n server: https://kubernetes.default.svc\n namespace: java-app\n syncPolicy:\n automated:\n prune: true\n selfHeal: true\n syncOptions:\n - CreateNamespace=true\n - ApplyOutOfSyncOnly=true\n\n\nApply:\nbash\nkubectl apply -f argocd-helm-app.yaml -n argocd\n\n\n‚úÖ Application becomes visible in ArgoCD UI.\n\n---\n\n## üåê Spring Boot Application Deployment\n\nBuild & Push Docker Image:\nbash\ndocker build -t venkatesh384/springboot-cicd-on-k8s:latest .\ndocker push venkatesh384/springboot-cicd-on-k8s:latest\n\n\nspringboot-deployment.yaml\nyaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n name: springboot-app\nspec:\n replicas: 2\n selector:\n matchLabels:\n app: springboot-app\n template:\n metadata:\n labels:\n app: springboot-app\n spec:\n containers:\n - name: springboot-app\n image: venkatesh384/springboot-cicd-on-k8s:latest\n ports:\n - containerPort: 8080\n\n\nspringboot-service.yaml\nyaml\napiVersion: v1\nkind: Service\nmetadata:\n name: springboot-service\nspec:\n type: LoadBalancer\n selector:\n app: springboot-app\n ports:\n - port: 80\n targetPort: 8080\n\n\nDeploy:\nbash\nkubectl apply -f springboot-deployment.yaml\nkubectl apply -f springboot-service.yaml\nkubectl get svc springboot-service\n\n\nAccess:\n\nhttp://<springboot-ELB-DNS>.ap-south-1.elb.amazonaws.com\n\n\n---\n\n## üîß Jenkins Pipeline & AWS/EKS Fixes\n\nExample Stage:\ngroovy\nstage('Configure AWS EKS Kubeconfig') {\n environment {\n AWS_REGION = 'ap-south-1'\n EKS_CLUSTER = 'java-eks'\n }\n steps {\n withCredentials([usernamePassword(\n credentialsId: 'aws-creds',\n usernameVariable: 'AWS_ACCESS_KEY_ID',\n passwordVariable: 'AWS_SECRET_ACCESS_KEY'\n )]) {\n sh '''\n export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID\n export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\n export AWS_DEFAULT_REGION=$AWS_REGION\n aws eks --region $AWS_REGION update-kubeconfig --name $EKS_CLUSTER\n kubectl get nodes\n '''\n }\n }\n}\n\n\n---\n\n## üõ†Ô∏è Troubleshooting\n\n| Issue | Solution |\n|----------------------------|----------|\n| Helm template errors | Check _helpers.tpl and Chart.yaml |\n| ArgoCD app not visible | Apply Application YAML, verify repo/path |\n| Ingress stuck | Ensure ingressClassName: nginx, check NGINX pods |\n| Service not reachable | Verify LoadBalancer EXTERNAL-IP & Security Group port 80 |\n| AWS CLI not found in Jenkins| Install AWS CLI in Jenkins agent |\n| AWS CLI credentials issue | Use Jenkins credentials plugin or EC2 IAM role |\n\n---\n\n## üîÑ Summary Flow\n1. Configure AWS CLI & IAM on EC2\n2. Create EKS cluster via eksctl\n3. Deploy Nginx to verify LoadBalancer & networking\n4. Prepare Helm chart (springboot-app)\n5. Deploy ArgoCD & expose UI\n6. Deploy Spring Boot app via Helm / ArgoCD\n7. (Optional) Setup NGINX Ingress\n8. Apply Jenkins pipeline fixes\n9. Verify pods, service, and access application"}]}}